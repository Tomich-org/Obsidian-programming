---
Тема: Python основы
tags:
  - python
  - основы
  - тип_данных
  - инструкции
Дата: 2023-11-28
---
Исключения - это тип данных, который предназначен для того, чтоб сообщать программисту об ошибках.

Самый простой пример ошибки - деление на ноль:
```py:
100/0
Traceback (most recent call last):
  File "", line 1, in
    100 / 0
ZeroDivisionError: division by zero
```

В этом примере интерпретатор сообщает нам о том, что он поймал исключение и напечатал информацию **Traceback (most recent call last)**.
Далее идет имя файла **File ""**, строка в файле **line 1**.
Выражение, в котором возникла ошибка **100/0**.
Название исключения **ZeroDivisionError** и краткое описание исключения **division by zero**.

Возможны и другие исключения, весь список:
- **BaseException** - базовое исключение, от которого берут начало все остальные.
    - **SystemExit** - исключение, порождаемое функцией sys.exit при выходе из программы.
    - **KeyboardInterrupt** - порождается при прерывании программы пользователем (обычно сочетанием клавиш Ctrl+C).
    - **GeneratorExit** - порождается при вызове метода close объекта generator.
    - **Exception** - а вот тут уже заканчиваются полностью системные исключения (которые лучше не трогать) и начинаются обыкновенные, с которыми можно работать.
        - **StopIteration** - порождается [[Встроенные функции|встроенной функцией]] next, если в итераторе больше нет элементов.
        - **ArithmeticError** - арифметическая ошибка.
            - **FloatingPointError** - порождается при неудачном выполнении операции с плавающей запятой. На практике встречается нечасто.
            - **OverflowError** - возникает, когда результат арифметической операции слишком велик для представления. Не появляется при обычной работе с целыми числами (так как python поддерживает длинные числа), но может возникать в некоторых других случаях.
            - **ZeroDivisionError** - деление на ноль.
        - **AssertionError** - выражение в функции assert ложно.
        - **AttributeError** - объект не имеет данного атрибута (значения или метода).
        - **BufferError** - операция, связанная с буфером, не может быть выполнена.
        - **EOFError** - функция наткнулась на конец файла и не смогла прочитать то, что хотела.
        - **ImportError** - не удалось импортирование модуля или его атрибута.
        - **LookupError** - некорректный индекс или ключ.
            - **IndexError** - индекс не входит в диапазон элементов.
            - **KeyError** - несуществующий ключ (в [[Словари(dict)|словаре]], [[Множества (set и frozenset)|множестве]] или другом объекте).
        - **MemoryError** - недостаточно памяти.
        - **NameError** - не найдено переменной с таким именем.
            - **UnboundLocalError** - сделана ссылка на локальную переменную в функции, но переменная не определена ранее.
        - **OSError** - ошибка, связанная с системой.
            - **BlockingIOError**
            - **ChildProcessError** - неудача при операции с дочерним процессом.
            - **ConnectionError** - базовый класс для исключений, связанных с подключениями.
                - **BrokenPipeError**
                - **ConnectionAbortedError**
                - **ConnectionRefusedError**
                - **ConnectionResetError**
            - **FileExistsError** - попытка создания [[Файлы|файла]] или директории, которая уже существует.
            - **FileNotFoundError** - файл или директория не существует.
            - **InterruptedError** - системный вызов прерван входящим сигналом.
            - **IsADirectoryError** - ожидался файл, но это директория.
            - **NotADirectoryError** - ожидалась директория, но это файл.
            - **PermissionError** - не хватает прав доступа.
            - **ProcessLookupError** - указанного процесса не существует.
            - **TimeoutError** - закончилось время ожидания.
        - **ReferenceError** - попытка доступа к атрибуту со слабой ссылкой.
        - **RuntimeError** - возникает, когда исключение не попадает ни под одну из других категорий.
        - **NotImplementedError** - возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.
        - **SyntaxError** - синтаксическая ошибка.
            - **IndentationError** - неправильные отступы.
                - **TabError** - смешивание в отступах табуляции и пробелов.
        - **SystemError** - внутренняя ошибка.
        - **TypeError** - операция применена к объекту несоответствующего типа.
        - **ValueError** - функция получает аргумент правильного типа, но некорректного значения.
        - **UnicodeError** - ошибка, связанная с кодированием / раскодированием unicode в [[Строки|строках]].
            - **UnicodeEncodeError** - исключение, связанное с кодированием unicode.
            - **UnicodeDecodeError** - исключение, связанное с декодированием unicode.
            - **UnicodeTranslateError** - исключение, связанное с переводом unicode.
        - **Warning** - предупреждение.

Примеры использования конструкции `try - except`
```py
try:
	k = 1 / 0
except ZeroDivisionError:
	k = 0
print(k) # 0
```

> [!note]
> Т.е. в блоке `try` мы выполняем инструкцию, которая может создать исключение, а в блоке except мы перехватываем это исключением.
> Но перехватываем не только исключение, но и все его потомки.
> Например, перехватывая **ArithmeticError**, мы так же перехватываем **FloatingPointError**, **OverflowError** и **ZeroDivisionError**.

>[!info]
>Также возможна инструкция except без аргументов, которая перехватывает вообще всё (и прерывание с клавиатуры, и системный выход и т. д.). Поэтому в такой форме инструкция except практически не используется, а используется except Exception. Однако чаще всего перехватывают исключения по одному, для упрощения отладки (вдруг вы ещё другую ошибку сделаете, а except её перехватит).

Есть еще две инструкции, относящиеся к данной теме: `finally` и `else`.
**Finally** выполняет блок инструкций в любом случае, было ли исключение, или нет.
Инструкция **else** выполняется в том случае, если исключения не было.