# Git Tag
Ветки просто изменить, они часто временны и постоянно меняют своё состояние.

В таком случае, где взять _постоянную_ ссылку на момент в истории изменений? Для таких вещей, как релиз и большие слияния, нужно нечто более постоянное, чем ветка.

Такое средство имеется. Git предоставляет нам теги, чья основная задача – ссылаться постоянно на конкретный коммит.

Важно, что после создания они никогда не сменят своего положения, так что можно с лёгкостью сделать checkout конкретного момента в истории изменений

Создадим тег на `C1`, который будет нашей версией 1
![[Pasted image 20250717214653.png]]
```bash
git tag v1 C1
```
![[Pasted image 20250717214711.png]]
Мы назвали тег `v1` и заставили его ссылаться на `C1` явным образом. Если конкретный коммит не указан, гит пометит тегом `HEAD`.

# Git Describe
Теги являются прекрасными ориентирами в истории изменений, поэтому в git есть команда, которая показывает, как далеко текущее состояние от ближайшего тега. И эта команда называется `git describe`

Git describe помогает сориентироваться после отката на много коммитов по истории изменений. Такое может случиться, когда вы сделали `git bisect` или если вы недавно вернулись из отпуска

Git describe выглядит примерно так:

`git describe <ref>`

Где `ref` — это что-либо, что указывает на конкретный коммит. Если не указать `ref`, то git будет считать, что указано текущее положение (`HEAD`).

Вывод команды выглядит примерно так:

`<tag>_<numCommits>_g<hash>`

Где `tag` – это ближайший тег в истории изменений, `numCommits` – это на сколько далеко мы от этого тега, а `hash` – это хеш коммита, который описывается.

Посмотрим на простой пример. Для дерева, показанного ниже:
![[Pasted image 20250717214956.png]]

```bash
git tag v2 C3
```
![[Pasted image 20250717215021.png]]

Команда `git describe main` выведет:
`v1_2_gC2`

Тогда как `git describe side` выведет:
`v2_1_gC4`