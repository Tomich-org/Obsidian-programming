---
Тема: C++
tags:
  - cpp
  - основы
  - строки
Дата: 2023-12-23
---
В c++ поддерживаются разные типы строк и символов, а также доступны различные способы выражения значений литералов каждого из этих типов. В исходном коде содержимое символьных и строковых литералов выражается с помощью кодировки. Универсальные имена символов и escape-символы позволяют представить любую строку, используя только основную кодировку исходного кода. Необработанные строковые литералы позволяют не использовать escape-символы и могут применяться для выражения всех типов строковых литералов. Возможно также создавать `std::string` литералы, не выполняя дополнительные действия по созданию или преобразованию.

```cpp
#include <string>
using namespace std::string_literals; // enables s-suffix for std::string literals

int main()
{
    // Character literals
    auto c0 =   'A'; // char
    auto c1 = u8'A'; // char
    auto c2 =  L'A'; // wchar_t
    auto c3 =  u'A'; // char16_t
    auto c4 =  U'A'; // char32_t

    // Multicharacter literals
    auto m0 = 'abcd'; // int, value 0x61626364

    // String literals
    auto s0 =   "hello"; // const char*
    auto s1 = u8"hello"; // const char* before C++20, encoded as UTF-8,
                         // const char8_t* in C++20
    auto s2 =  L"hello"; // const wchar_t*
    auto s3 =  u"hello"; // const char16_t*, encoded as UTF-16
    auto s4 =  U"hello"; // const char32_t*, encoded as UTF-32

    // Raw string literals containing unescaped \ and "
    auto R0 =   R"("Hello \ world")"; // const char*
    auto R1 = u8R"("Hello \ world")"; // const char* before C++20, encoded as UTF-8,
                                      // const char8_t* in C++20
    auto R2 =  LR"("Hello \ world")"; // const wchar_t*
    auto R3 =  uR"("Hello \ world")"; // const char16_t*, encoded as UTF-16
    auto R4 =  UR"("Hello \ world")"; // const char32_t*, encoded as UTF-32

    // Combining string literals with standard s-suffix
    auto S0 =   "hello"s; // std::string
    auto S1 = u8"hello"s; // std::string before C++20, std::u8string in C++20
    auto S2 =  L"hello"s; // std::wstring
    auto S3 =  u"hello"s; // std::u16string
    auto S4 =  U"hello"s; // std::u32string

    // Combining raw string literals with standard s-suffix
    auto S5 =   R"("Hello \ world")"s; // std::string from a raw const char*
    auto S6 = u8R"("Hello \ world")"s; // std::string from a raw const char* before C++20, encoded as UTF-8,
                                       // std::u8string in C++20
    auto S7 =  LR"("Hello \ world")"s; // std::wstring from a raw const wchar_t*
    auto S8 =  uR"("Hello \ world")"s; // std::u16string from a raw const char16_t*, encoded as UTF-16
    auto S9 =  UR"("Hello \ world")"s; // std::u32string from a raw const char32_t*, encoded as UTF-32
}
```

Строковые литералы не могут иметь префикс или `u8` `L`, `u` и `U` префиксы для обозначения узкого символа, UTF-8, широкий символа (однобайтового и многобайтового), UTF-8, широкий символ (UCS-2 или UTF-16), кодировки UTF-16, и UTF-32 соответственно. 

Дополнительные сведения о базовом наборе исходных символов, универсальных именах символов и использовании символов из расширенных кодовых страниц в исходном коде подробнее в [[Маркеры и наборы символов]]
# Символьные литералы
*Символьный литерал* состоит из символьной константы. Он представлен символом, окруженным одними кавычками. Существует пять типов символьных литерала:
- Обычными символьные литералы типа `char`, например `'a'`
- Символьные литералы UTF-8 типа `char`, например `u8'a'`
- Расширенные символьные литералы типа `wchar_t`, например `L'a'`
- Символьные литералы типа `char16_t` UTF-16, например `u'a'`
- Символьные литералы типа `char32_t` UTF-32, например `U'a'`

Символ, используемый для литерала символов, может быть любым символом, за исключением зарезервированных символов обратной косой черты (`\`), одной кавычки  (**`'`**) или новой строки. Зарезервированные символы можно указывать с помощью escape-последовательности. Символы можно указать с помощью универсальных имен символов, при условии что тип является достаточно крупным для размещения символа.

# Кодировка
Литералы символов кодируются по-разному на основе префикса.
- **Литерал символов без префикса** — обычный символьный литерал. Значение обычного символьного литерала, содержащего один символ, escape-последовательность или универсальное имя символа, которое может быть представлено в наборе символов выполнения, имеет значение, равное числовому значению его кодировки в наборе символов выполнения. Обычный литерал символов, содержащий несколько символов, escape-последовательность или универсальное имя символов, является многофакторным _литералом_. Многофакторный литерал или обычный символьный литерал, который не может быть представлен в наборе символов выполнения, имеет тип **`int`**, и его значение определяется реализацией. 
- **Символьный литерал, начинающийся с `L` префикса**, — это символьный литерал. Значение символьного литерала, содержащего один символ, escape-последовательность или универсальное имя символов, имеет значение, равное числовому значению его кодировки в наборе символов, если литерал символов не имеет представления в наборе расширенных символов выполнения, в этом случае значение определяется реализацией. Значение расширенных символьных литералов, содержащих несколько символов, escape-последовательностей или универсальных имен символов, определяется реализацией. 
- **Символьный литерал, начинающийся с `u8` префикса**, — это символьный литерал UTF-8. Значение символьного литерала UTF-8, содержащего один символ, escape-последовательность или универсальное имя символов, имеет значение, равное значению точки кода ISO 10646, если оно может быть представлено одним блоком кода UTF-8 (соответствующим блоку элементов управления C0 и Basic Latin Юникод). Если значение не может быть представлено одним блоком кода UTF-8, программа не сформирована. Символьный литерал UTF-8, содержащий несколько символов, escape-последовательность или универсальное имя символов, является неправильно сформированным.
- **Символьный литерал, начинающийся с `u` префикса**, является литералом символов UTF-16. Значение символьного литерала UTF-16, содержащего один символ, escape-последовательность или универсальное имя символов, имеет значение, равное значению точки кода ISO 10646, если оно может быть представлено одной единицей кода UTF-16 (соответствующей базовой многоязычной плоскости). Если значение не может быть представлено одним блоком кода UTF-16, программа не сформирована. Литерал символа UTF-16, содержащий несколько символов, escape-последовательность или универсальное имя символов, является неправильно сформированным.
- **Символьный литерал, начинающийся с `U` префикса**, — это символьный литерал UTF-32. Значение символьного литерала UTF-32, содержащего один символ, escape-последовательность или универсальное имя символов, имеет значение, равное значению точки кода ISO 10646. Символьный литерал UTF-32, содержащий несколько символов, escape-последовательность или универсальное имя символов, является неправильно сформированным.
# Escape-последовательности
Существует три вида escape-последовательностей:
- Простая
- Восьмеричная
- Шестнадцатеричная
Escape-последовательности могут быть любым из следующих значений:

|Значение|escape-последовательность|
|---|---|
|новая строка|\n|
|обратная косая черта|\\|
|горизонтальная табуляция|\t|
|вопросительный знак|? Или\?|
|вертикальная табуляция|\v|
|одинарная кавычка|\'|
|BACKSPACE|\b|
|двойная кавычка|\"|
|Возврат каретки|\r|
|нуль-символ|\0|
|Смена страницы|\f|
|восьмеричный|\ooo|
|оповещение (колокольчик)|\a|
|шестнадцатеричный|\xhhh|

Восьмеричная escape-последовательность — это обратная косая черта, за которой следует последовательность из одной до трех восьмеричных цифр. Восьмеричная escape-последовательность завершается на первом символе, который не является восьмеричной цифрой, если обнаружена раньше, чем третья цифра. Максимально возможное восьмеричное значение .`\377`

Шестнадцатеричная escape-последовательность — это обратная косая черта, за которой следует символ `x`, за которой следует последовательность одной или нескольких шестнадцатеричных цифр. Начальные нули пропускаются. В обычном или префиксном литерале символов u8 самое высокое шестнадцатеричное значение 0xFF. В расширенном символьном литерале с префиксом L или u максимальное шестнадцатеричное значение — 0xFFFF. В расширенном символьном литерале с префиксом U максимальное шестнадцатеричное значение — 0xFFFFFFFF.

В этом примере кода показаны некоторые примеры экранированных символов с помощью обычных литералов символов. Тот же синтаксис escape-последовательности действителен для других типов литеральных символов.

```cpp
#include <iostream>
using namespace std;

int main() {
    char newline = '\n';
    char tab = '\t';
    char backspace = '\b';
    char backslash = '\\';
    char nullChar = '\0';

    cout << "Newline character: " << newline << "ending" << endl;
    cout << "Tab character: " << tab << "ending" << endl;
    cout << "Backspace character: " << backspace << "ending" << endl;
    cout << "Backslash character: " << backslash << "ending" << endl;
    cout << "Null character: " << nullChar << "ending" << endl;
}
/* Output:
Newline character:
ending
Tab character:  ending
Backspace character:ending
Backslash character: \ending
Null character:  ending
*/
```
# Строковые литералы
Строковый литерал представляет последовательность символов, которые вместе образуют строку с завершающим нулем. Символы должны быть заключены в двойные кавычки.
## Узкие строковые литералы
Узкий сроковый литерал - это не префиксированный, разделенный двойными кавычками массив `const char[n]` типа, в котором n - длина массива в байтах. Обычный строковый литерал может содержать любые графические символы, за исключением двойных кавычек (`"`), обратной косой черты (`\`) или символа новой строки. Обычный строковый литерал также может содержать перечисленные выше escape-последовательности и универсальные имена символов, которые помещаются в байте.
```cpp
const char *narrow = "abcd";

// represents the string: yes\no
const char *escaped = "yes\\no";
```
## Строки в кодировке UTF-8
Строка в кодировке UTF-8 — это префиксированный, разделенный двойным кавычками массив типа, завершаемый значением NULL, где _n_ — длина закодированного массива `const char[n]`в байтах. Строковый литерал с префиксом u8 может содержать любые графические символы, за исключением двойных кавычек (`"`), обратной косой черты (`\`) или символа новой строки. Строковый литерал с префиксом u8 может также содержать перечисленные выше escape-последовательности и любые универсальные имена символов.
```cpp
// Before C++20
const char* str1 = u8"Hello World";
const char* str2 = u8"\U0001F607 is O:-)";
// C++20 and later
const char8_t* u8str1 = u8"Hello World";
const char8_t* u8str2 = u8"\U0001F607 is O:-)";
```
# Расширенные строковые литералы
Широкий строковый литерал — это массив констант **`wchar_t`** , префиксируемый символом null, который префиксируется "`L`" и содержит любой графический символ, кроме двойной кавычки (**`"`**), обратной косой черты (**`\`**) или символа новой строки. Расширенный строковый литерал может содержать перечисленные выше escape-последовательности и любые универсальные имена символов.
```cpp
const wchar_t* wide = L"zyxw";
const wchar_t* newline = L"hello\ngoodbye";
```
# Изменение строковых литерала
Так как строковые литералы (не включая `std::string` литералы) являются константами, пытаясь изменить их( например, `str[2] = 'A'`вызывает ошибку компилятора.
# Сцепление смежных строковых литералов
Все смежные расширенные и узкие строковые литералы соединяются. Данное объявление:
```cpp
char str[] = "12" "34";
```
идентично следующему объявлению:
```cpp
char atr[] = "1234";
```
и следующему объявлению:
```cpp
char atr[] =  "12\
34";
```
Использование внедренных шестнадцатеричных escape-кодов для задания строковых литералов может привести к непредвиденным результатам. В следующем примере выполняется попытка создать строковый литерал, содержащий символ ASCII 5, за которым следуют символы f, i, v и e:
```cpp
"\x05five"
```
